#!/usr/bin/awk -F, -f

BEGIN {
    FS=","
    print "#!/usr/bin/awk -F, -f" RS

    print "# generated by: awk-csvalid https://github.com/tesera/awk-csvalid" RS
    print "# awk-csvalid csv toolset generator: https://github.com/tesera/awk-csvalid"
    print "# usage:"
    print "#    validate:     awk -f action=validate validator.awk > violations.txt"
    print "#    create table: awk -v action=table -f validator.awk | psql afgo_dev"
    print "#    sanitize csv: awk -v action=sanitize -f validator.awk > sanitized.csv"
    print "#    insert sql:   awk -v action=insert -f validator.awk | psql afgo_dev" RS
    print "# awk is a simple unix text file parser: http://www.gnu.org/software/gawk/manual/gawk.html"
    print "# awk primer:"
    print "#    NR = number/index current record"
    print "#    RS = record seperator new line i.e. \\n"
    print "#    FS = field seperator i.e. ,"
    print "#    /pattern/ { expression } = if pattern is truthy run expression" RS

    print "BEGIN {"
    print "    FS=\",\"; OFS=\",\"; err_count=0; cats[\"na\"]=0;"
    print "    if(!action) action == \"validate\""
    print "}" RS

    print "# builtin helper functions"
    print "function eql(x,y) {v=1; for (i in x) v=(v&&x[i]==y[i]); return v;}"
    print "function are_headers_valid(valid_headers) { v=0; split($0, h, \",\"); split(valid_headers, vh, \"|\"); return eql(h, vh); }"
    print "function is_unique(i, val) { if (vals[i,val]) { return 0; } else { vals[i,val] = 1; return 1; } }"
    print "function is_numeric(x){ return(x==x+0) }"
    print "function print_cats(categories) { for (category in categories) { if (categories[category]) print \"      \" category \": \" categories[category]; } }"
    print "function log_err(cat) { cats[cat]++; err_count++; }"
    print RS
}

$1 == "option" { 
    options[$2]=$3;
}

$1 == "headers" && $2 == "names" {
    split($3, headers, "|")
    print "# make header index/map"
    print "NR > 1 {"
    for (i in headers) {
        header_name = headers[i]
        header_index[header_name] = i
        print "    " headers[i]  "=$" i
    }

    print "}" RS
    print "# awk rules based on user csv ruleset"
    print "NR == 1 { headers=\"" $3 "\"; if (!are_headers_valid(headers)) print \"invalid headers\" }"
}

$1 == "field" {
    rule_type=$2
    split($3,params," ")
    field=params[1]
    cat=params[3]
    field_index=header_index[field]
    test=""
    msg=""

    if (rule_type == "type") {
        type=params[2]
        if (type == "numeric"){
            test=field " && !is_numeric(" field ")"
            msg="Field " field " in \" FILENAME \" line \" NR \" should be a numeric but was \" " field " \" "
        }
    } else if (rule_type == "required") {
        test=field " == \"\""
        msg="Field " field " in \" FILENAME \" line \" NR \" is required"
    } else if (rule_type == "unique") {
        test="!is_unique(" field ")"
        msg="Field " field " in \" FILENAME \" line \" NR \" is a duplicate and should be unique"
    } else if (rule_type ~ /^min|max$/) {
        comparator=$2 == "max" ? ">" : "<"
        limit=params[2]
        term=$2 == "max" ? "less" : "greater"

        test=field " " comparator " " limit
        msg=field " in line \" NR \" should be " term " than " limit " and was \" " field " \" "
    } else if (rule_type == "values") {
        values=params[2]

        test=field " != \"\" && " field " !~ /^(" values ")$/"
        msg=field " in line \" NR \" should be one of " values " and was \" " field " \" "
    }

    if (!options["mode"]) options["mode"] = "text"
    if (!options["dcat"]) options["dcat"] = "na"
    if (!cat) cat = options["dcat"]
    handler_prefix="{ log_err(\"" cat "\"); "
    if (options["mode"] == "text") {
        err_handler= handler_prefix "print \"" msg "\" RS $0 RS; }" 
    } else if (options["mode"] == "wrap") {
        acc="$" field_index
        err_handler= handler_prefix "FS=\",\";" acc "=\">>\" " acc " \"<<\"; print $0 }" 
    } else if (options["mode"] == "append") {
        err_handler= handler_prefix "print $0 FS \"" msg "\" }"
    }

    if (rule_type !~ /^(none|colmap)$/) { print "action == \"validate\" && NR > 1 && " test " " err_handler " " }
}

$1 == "field" {
    rule_type=$2
    split($3,params," ")
    field=params[1]

    if (rule_type ~ /^(min|max)$/ || (rule_type == "type" && params[2] == "numeric")) {
        types[field] = "numeric"
    } else if (rule_type != "colmap") {
        types[field] = "text"
    }

    if(rule_type == "colmap") mappings[field]=params[2]
}

END {
    print RS "# sanitize rules"
    print "action ~ /^(sanitize|insert)$/ && NR > 1 {"
    for (field in types) {
        type=types[field]
        field_index=header_index[field]
        dval= type == "numeric" ? options["dvalnum"] : options["dvalstr"]
        print "    if (" field " == \"\") $" field_index " = \"" dval "\""
    }
    print "}"

    print RS "# action handlers"
    print "action == \"insert\" && NR == 1 {"
    print "    print \"SET client_encoding = 'UTF8';\""
    print "    gsub(\"Range\", \"rangeno\");"
    print "    print \"COPY " options["table"] " (\" $0 \") FROM stdin;\""
    print "}"

    print "action == \"insert\" && NR > 1 {"
    print "    gsub(\",\", \"\t\");"
    print "    print;"
    print "}"

    print "action == \"table\" && NR == 1 {"

    fields=""
    l=length(headers)
    for (i in headers) {
        c++
        field=headers[i]
        type=types[field]
        if (length(mappings) && mappings[field]) field=mappings[field]
        fields=fields field " " type
        if (c < l) fields=fields ","
    }

    if(options["pkey"]) {
        cols=options["pkey"]
        gsub(":", ",", cols)
        fields=fields ", PRIMARY KEY (" cols ") "
    }
    if(options["fkey"]) {
        split(options["fkey"], ref, " ")
        ftable=ref[1]
        fcols=ref[2]
        gsub(":", ",", fcols)
        fields=fields ", FOREIGN KEY (" fcols ") REFERENCES " ftable " (" fcols ") MATCH FULL "
    }

    print "     print \"CREATE TABLE IF NOT EXISTS " options["table"] " (" fields ");\""
    print "}"

    print "action == \"sanitize\" { print }" RS

    print "# la fin"
    print "END {" 
    print "    if (action == \"insert\") print \"\\\\.\""
    print "    if (action == \"validate\") print RS \"violation summary: \" RS \"   counts:   \" RS \"      total: \" err_count; print_cats(cats); "
    print "}"
}